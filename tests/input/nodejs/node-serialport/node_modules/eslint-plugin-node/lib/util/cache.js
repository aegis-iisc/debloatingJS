/**
 * @author Toru Nagashima
 * @copyright 2016 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SKIP_TIME = 5000;

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The class of cache.
 * The cache will dispose of each value if the value has not been accessed
 * during 5 seconds.
 */
module.exports = function () {
    /**
     * Initialize this cache instance.
     */
    function Cache() {
        _classCallCheck(this, Cache);

        this.map = new Map();
    }

    /**
     * Get the cached value of the given key.
     * @param {any} key The key to get.
     * @returns {any} The cached value or null.
     */


    _createClass(Cache, [{
        key: "get",
        value: function get(key) {
            var entry = this.map.get(key);
            var now = Date.now();

            if (entry) {
                if (entry.expire > now) {
                    entry.expire = now + SKIP_TIME;
                    return entry.value;
                }
                this.map.delete(key);
            }
            return null;
        }

        /**
         * Set the value of the given key.
         * @param {any} key The key to set.
         * @param {any} value The value to set.
         * @returns {void}
         */

    }, {
        key: "set",
        value: function set(key, value) {
            var entry = this.map.get(key);
            var expire = Date.now() + SKIP_TIME;

            if (entry) {
                entry.value = value;
                entry.expire = expire;
            } else {
                this.map.set(key, { value: value, expire: expire });
            }
        }
    }]);

    return Cache;
}();