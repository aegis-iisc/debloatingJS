/**
 * @fileoverview Rule to check whether or not `require()` is valid.
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var path = require("path");
var getAllowModules = require("./get-allow-modules");
var getConvertPath = require("./get-convert-path");
var getNpmignore = require("./get-npmignore");
var getPackageJson = require("./get-package-json");

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Checks whether or not each requirement target is published via package.json.
 *
 * It reads package.json and checks the target exists in `dependencies`.
 *
 * @param {RuleContext} context - A context to report.
 * @param {string} filePath - The current file path.
 * @param {ImportTarget[]} targets - A list of target information to check.
 * @returns {void}
 */
module.exports = function checkForPublish(context, filePath, targets) {
    var packageInfo = getPackageJson(filePath);
    if (!packageInfo) {
        return;
    }

    var allowed = new Set(getAllowModules(context));
    var convertPath = getConvertPath(context);
    var basedir = path.dirname(packageInfo.filePath);
    var toRelative = function toRelative(fullPath) {
        // eslint-disable-line func-style
        var retv = path.relative(basedir, fullPath).replace(/\\/g, "/");
        return convertPath(retv);
    };
    var npmignore = getNpmignore(filePath);
    var devDependencies = new Set(Object.keys(packageInfo.devDependencies || {}));
    var dependencies = new Set([].concat(Object.keys(packageInfo.dependencies || {}), Object.keys(packageInfo.peerDependencies || {}), Object.keys(packageInfo.optionalDependencies || {})));

    if (!npmignore.match(toRelative(filePath))) {
        // This file is published, so this cannot import private files.
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = targets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var target = _step.value;

                var isPrivateFile = target.moduleName == null && npmignore.match(toRelative(target.filePath));
                var isDevPackage = target.moduleName != null && devDependencies.has(target.moduleName) && !dependencies.has(target.moduleName) && !allowed.has(target.moduleName);

                if (isPrivateFile || isDevPackage) {
                    context.report({
                        node: target.node,
                        loc: target.node.loc,
                        message: "\"{{name}}\" is not published.",
                        data: { name: target.moduleName || target.name }
                    });
                }
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }
    }
};