/**
 * @author Toru Nagashima
 * @copyright 2016 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var path = require("path");
var resolve = require("resolve");
var getResolvePaths = require("./get-resolve-paths");
var getTryExtensions = require("./get-try-extensions");
var ImportTarget = require("./import-target");
var stripImportPathParams = require("./strip-import-path-params");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

var MODULE_TYPE = /^(?:Import|Export(?:Named|Default|All))Declaration$/;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Gets a list of `import`/`export` declaration targets.
 *
 * Core modules of Node.js (e.g. `fs`, `http`) are excluded.
 *
 * @param {RuleContext} context - The rule context.
 * @param {ASTNode} programNode - The node of Program.
 * @param {boolean} includeCore - The flag to include core modules.
 * @returns {ImportTarget[]} A list of found target's information.
 */
module.exports = function getImportExportTargets(context, programNode, includeCore) {
    var retv = [];
    var basedir = path.dirname(path.resolve(context.getFilename()));
    var paths = getResolvePaths(context);
    var extensions = getTryExtensions(context);
    var options = { basedir: basedir, paths: paths, extensions: extensions };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = programNode.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var statement = _step.value;

            // Skip if it's not a module declaration.
            if (!MODULE_TYPE.test(statement.type)) {
                continue;
            }

            // Gets the target module.
            var node = statement.source;
            var name = node && stripImportPathParams(node.value);
            if (name && (includeCore || !resolve.isCore(name))) {
                retv.push(new ImportTarget(node, name, options));
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return retv;
};