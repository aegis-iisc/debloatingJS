/**
 * @author Toru Nagashima
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var semver = require("semver");
var features = require("../util/features");
var getDocsUrl = require("../util/get-docs-url");
var getPackageJson = require("../util/get-package-json");
var getValueIfString = require("../util/get-value-if-string");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

var VERSION_MAP = new Map([[0.1, "0.10.0"], [0.12, "0.12.0"], [4, "4.0.0"], [5, "5.0.0"], [6, "6.0.0"], [6.5, "6.5.0"], [7, "7.0.0"], [7.6, "7.6.0"], [8, "8.0.0"], [8.3, "8.3.0"], [9, "9.0.0"], [10, "10.0.0"]]);
var VERSION_SCHEMA = {
    anyOf: [{ enum: Array.from(VERSION_MAP.keys()) }, {
        type: "string",
        pattern: "^(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)\\.(?:0|[1-9]\\d*)$"
    }]
};
var DEFAULT_VERSION = "4.0.0";
var OPTIONS = Object.keys(features);
var FUNC_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/;
var CLASS_TYPE = /^Class(?:Declaration|Expression)$/;
var DESTRUCTURING_PARENT_TYPE = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression|AssignmentExpression|VariableDeclarator)$/;
var TOPLEVEL_SCOPE_TYPE = /^(?:global|function|module)$/;
var BINARY_NUMBER = /^0[bB]/;
var OCTAL_NUMBER = /^0[oO]/;
var UNICODE_ESC = /(\\+)u\{[0-9a-fA-F]+?\}/g;
var GET_OR_SET = /^(?:g|s)et$/;
var NEW_BUILTIN_TYPES = ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "DataView", "Map", "Set", "WeakMap", "WeakSet", "Proxy", "Reflect", "Promise", "Symbol", "SharedArrayBuffer", "Atomics"];
var SUBCLASSING_TEST_TARGETS = ["Array", "RegExp", "Function", "Promise", "Boolean", "Number", "String", "Map", "Set"];
var PROPERTY_TEST_TARGETS = {
    Object: ["assign", "is", "getOwnPropertySymbols", "setPrototypeOf", "values", "entries", "getOwnPropertyDescriptors"],
    String: ["raw", "fromCodePoint"],
    Array: ["from", "of"],
    Number: ["isFinite", "isInteger", "isSafeInteger", "isNaN", "EPSILON", "MIN_SAFE_INTEGER", "MAX_SAFE_INTEGER"],
    Math: ["clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "trunc", "fround", "cbrt", "hypot"],
    Symbol: ["hasInstance", "isConcatSpreadablec", "iterator", "species", "replace", "search", "split", "match", "toPrimitive", "toStringTag", "unscopables"],
    Atomics: ["add", "and", "compareExchange", "exchange", "wait", "wake", "isLockFree", "load", "or", "store", "sub", "xor"]
};
var REGEXP_NAMED_GROUP = /(\\*)\(\?<[_$\w]/;
var REGEXP_LOOKBEHIND = /(\\*)\(\?<[=!]/;
var REGEXP_UNICODE_PROPERTY = /(\\*)\\[pP]{.+?}/;

/**
 * Gets default version configuration of this rule.
 *
 * This finds and reads 'package.json' file, then parses 'engines.node' field.
 * If it's nothing, this returns null.
 *
 * @param {string} filename - The file name of the current linting file.
 * @returns {string} The default version configuration.
 */
function getDefaultVersion(filename) {
    var info = getPackageJson(filename);
    var nodeVersion = info && info.engines && info.engines.node;

    return semver.validRange(nodeVersion) || DEFAULT_VERSION;
}

/**
 * Gets values of the `ignores` option.
 *
 * @returns {string[]} Values of the `ignores` option.
 */
function getIgnoresEnum() {
    return Object.keys(OPTIONS.reduce(function (retv, key) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
            for (var _iterator = features[key].alias[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var alias = _step.value;

                retv[alias] = true;
            }
        } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                }
            } finally {
                if (_didIteratorError) {
                    throw _iteratorError;
                }
            }
        }

        retv[key] = true;
        return retv;
    }, Object.create(null)));
}

/**
 * Checks whether a given key should be ignored or not.
 *
 * @param {string} key - A key to check.
 * @param {string[]} ignores - An array of keys and aliases to be ignored.
 * @returns {boolean} `true` if the key should be ignored.
 */
function isIgnored(key, ignores) {
    return ignores.indexOf(key) !== -1 || features[key].alias.some(function (alias) {
        return ignores.indexOf(alias) !== -1;
    });
}

/**
 * Parses the options.
 *
 * @param {number|string|object|undefined} options - An option object to parse.
 * @param {number} defaultVersion - The default version to use if the version option was omitted.
 * @returns {object} Parsed value.
 */
function parseOptions(options, defaultVersion) {
    var version = null;
    var range = null;
    var ignores = [];

    if (typeof options === "number") {
        version = VERSION_MAP.get(options);
    } else if (typeof options === "string") {
        version = options;
    } else if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
        version = typeof options.version === "number" ? VERSION_MAP.get(options.version) : options.version;

        ignores = options.ignores || [];
    }

    range = semver.validRange(version ? ">=" + version : defaultVersion);
    if (!version) {
        version = defaultVersion;
    }

    return Object.freeze({
        version: version,
        features: Object.freeze(OPTIONS.reduce(function (retv, key) {
            var feature = features[key];

            if (isIgnored(key, ignores)) {
                retv[key] = Object.freeze({
                    name: feature.name,
                    singular: Boolean(feature.singular),
                    supported: true,
                    supportedInStrict: true
                });
            } else if (typeof feature.node === "string") {
                retv[key] = Object.freeze({
                    name: feature.name,
                    singular: Boolean(feature.singular),
                    supported: !semver.intersects(range, "<" + feature.node),
                    supportedInStrict: !semver.intersects(range, "<" + feature.node)
                });
            } else {
                retv[key] = Object.freeze({
                    name: feature.name,
                    singular: Boolean(feature.singular),
                    supported: feature.node != null && feature.node.sloppy != null && !semver.intersects(range, "<" + feature.node.sloppy),
                    supportedInStrict: feature.node != null && feature.node.strict != null && !semver.intersects(range, "<" + feature.node.strict)
                });
            }

            return retv;
        }, Object.create(null)))
    });
}

/**
 * Checks whether or not the current configure has a special lexical environment.
 * If it's modules or globalReturn then it has a special lexical environment.
 *
 * @param {RuleContext} context - A context to check.
 * @returns {boolean} `true` if the current configure is modules or globalReturn.
 */
function checkSpecialLexicalEnvironment(context) {
    var parserOptions = context.parserOptions;
    var ecmaFeatures = parserOptions.ecmaFeatures;
    return Boolean(parserOptions.sourceType === "module" || ecmaFeatures && ecmaFeatures.globalReturn);
}

/**
 * Gets the name of a given node.
 *
 * @param {ASTNode} node - An Identifier node to get.
 * @returns {string} The name of the node.
 */
function getIdentifierName(node) {
    return node.name;
}

/**
 * Checks whether the given string has `\u{90ABCDEF}`-like escapes.
 *
 * @param {string} raw - The string to check.
 * @returns {boolean} `true` if the string has Unicode code point escapes.
 */
function hasUnicodeCodePointEscape(raw) {
    var match = null;

    UNICODE_ESC.lastIndex = 0;
    while ((match = UNICODE_ESC.exec(raw)) != null) {
        if (match[1].length % 2 === 1) {
            return true;
        }
    }

    return false;
}

/**
 * Check a given string has a given pattern.
 * @param {string} s A string to check.
 * @param {RegExp} pattern A RegExp object to check.
 * @returns {boolean} `true` if the string has the pattern.
 */
function hasPattern(s, pattern) {
    var m = pattern.exec(s);
    return m != null && (m[1] || "").length % 2 === 0;
}

/**
 * The definition of this rule.
 *
 * @param {RuleContext} context - The rule context to check.
 * @returns {object} The definition of this rule.
 */
function create(context) {
    var _marked = /*#__PURE__*/regeneratorRuntime.mark(getReferences);

    var sourceCode = context.getSourceCode();
    var supportInfo = parseOptions(context.options[0], getDefaultVersion(context.getFilename()));
    var hasSpecialLexicalEnvironment = checkSpecialLexicalEnvironment(context);

    /**
     * Gets the references of the specified global variables.
     *
     * @param {string[]} names - Variable names to get.
     * @returns {void}
     */
    function getReferences(names) {
        var globalScope, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, name, variable;

        return regeneratorRuntime.wrap(function getReferences$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        globalScope = context.getScope();
                        _iteratorNormalCompletion2 = true;
                        _didIteratorError2 = false;
                        _iteratorError2 = undefined;
                        _context.prev = 4;
                        _iterator2 = names[Symbol.iterator]();

                    case 6:
                        if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                            _context.next = 14;
                            break;
                        }

                        name = _step2.value;
                        variable = globalScope.set.get(name);

                        if (!(variable && variable.defs.length === 0)) {
                            _context.next = 11;
                            break;
                        }

                        return _context.delegateYield(variable.references, "t0", 11);

                    case 11:
                        _iteratorNormalCompletion2 = true;
                        _context.next = 6;
                        break;

                    case 14:
                        _context.next = 20;
                        break;

                    case 16:
                        _context.prev = 16;
                        _context.t1 = _context["catch"](4);
                        _didIteratorError2 = true;
                        _iteratorError2 = _context.t1;

                    case 20:
                        _context.prev = 20;
                        _context.prev = 21;

                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
                            _iterator2.return();
                        }

                    case 23:
                        _context.prev = 23;

                        if (!_didIteratorError2) {
                            _context.next = 26;
                            break;
                        }

                        throw _iteratorError2;

                    case 26:
                        return _context.finish(23);

                    case 27:
                        return _context.finish(20);

                    case 28:
                    case "end":
                        return _context.stop();
                }
            }
        }, _marked, this, [[4, 16, 20, 28], [21,, 23, 27]]);
    }

    /**
     * Checks whether or not the current scope is strict mode.
     *
     * @returns {boolean}
     *      `true` if the current scope is strict mode. Otherwise `false`.
     */
    function isStrict() {
        var scope = context.getScope();
        if (scope.type === "global" && hasSpecialLexicalEnvironment) {
            scope = scope.childScopes[0];
        }
        return scope.isStrict;
    }

    /**
     * Checks whether the given function has trailing commas or not.
     *
     * @param {ASTNode} node - The function node to check.
     * @returns {boolean} `true` if the function has trailing commas.
     */
    function hasTrailingCommaForFunction(node) {
        var length = node.params.length;

        return length >= 1 && sourceCode.getTokenAfter(node.params[length - 1]).value === ",";
    }

    /**
     * Checks whether the given call expression has trailing commas or not.
     *
     * @param {ASTNode} node - The call expression node to check.
     * @returns {boolean} `true` if the call expression has trailing commas.
     */
    function hasTrailingCommaForCall(node) {
        return node.arguments.length >= 1 && sourceCode.getLastToken(node, 1).value === ",";
    }

    /**
     * Checks whether the given class extends from null or not.
     *
     * @param {ASTNode} node - The class node to check.
     * @returns {boolean} `true` if the class extends from null.
     */
    function extendsNull(node) {
        return node.superClass != null && node.superClass.type === "Literal" && node.superClass.value === null;
    }

    /**
     * Reports a given node if the specified feature is not supported.
     *
     * @param {ASTNode} node - A node to be reported.
     * @param {string} key - A feature name to report.
     * @returns {void}
     */
    function report(node, key) {
        var version = supportInfo.version;
        var feature = supportInfo.features[key];
        if (feature.supported) {
            return;
        }

        if (!feature.supportedInStrict) {
            context.report({
                node: node,
                message: "{{feature}} {{be}} not supported yet on Node {{version}}.",
                data: {
                    feature: feature.name,
                    be: feature.singular ? "is" : "are",
                    version: version
                }
            });
        } else if (!isStrict()) {
            context.report({
                node: node,
                message: "{{feature}} {{be}} not supported yet on Node {{version}}.",
                data: {
                    feature: feature.name + " in non-strict mode",
                    be: feature.singular ? "is" : "are",
                    version: version
                }
            });
        }
    }

    /**
     * Validate RegExp syntax.
     * @param {string} pattern A RegExp pattern to check.
     * @param {string} flags A RegExp flags to check.
     * @param {ASTNode} node A node to report.
     * @returns {void}
     */
    function validateRegExp(pattern, flags, node) {
        if (typeof pattern === "string") {
            if (hasPattern(pattern, REGEXP_NAMED_GROUP)) {
                report(node, "regexpNamedCaptureGroups");
            }
            if (hasPattern(pattern, REGEXP_LOOKBEHIND)) {
                report(node, "regexpLookbehind");
            }
            if (hasPattern(pattern, REGEXP_UNICODE_PROPERTY)) {
                report(node, "regexpUnicodeProperties");
            }
        }
        if (typeof flags === "string") {
            if (flags.indexOf("y") !== -1) {
                report(node, "regexpY");
            }
            if (flags.indexOf("u") !== -1) {
                report(node, "regexpU");
            }
            if (flags.indexOf("s") !== -1) {
                report(node, "regexpS");
            }
        }
    }

    /**
     * Validate RegExp syntax in a RegExp literal.
     * @param {ASTNode} node A Literal node to check.
     * @returns {void}
     */
    function validateRegExpLiteral(node) {
        validateRegExp(node.regex.pattern, node.regex.flags, node);
    }

    /**
     * Validate RegExp syntax in the first argument of `new RegExp()`.
     * @param {ASTNode} node A NewExpression node to check.
     * @returns {void}
     */
    function validateRegExpString(node) {
        var patternNode = node.arguments[0];
        var flagsNode = node.arguments[1];
        var pattern = patternNode && patternNode.type === "Literal" && typeof patternNode.value === "string" ? patternNode.value : null;
        var flags = flagsNode && flagsNode.type === "Literal" && typeof flagsNode.value === "string" ? flagsNode.value : null;
        validateRegExp(pattern, flags, node);
    }

    return {
        //----------------------------------------------------------------------
        // Program
        //----------------------------------------------------------------------

        //eslint-disable-next-line complexity
        "Program:exit": function ProgramExit() {
            // Check new global variables.
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
                for (var _iterator3 = NEW_BUILTIN_TYPES[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var name = _step3.value;
                    var _iteratorNormalCompletion6 = true;
                    var _didIteratorError6 = false;
                    var _iteratorError6 = undefined;

                    try {
                        for (var _iterator6 = getReferences([name])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                            var reference = _step6.value;

                            // Ignore if it's using new static methods.
                            var node = reference.identifier;
                            var parentNode = node.parent;
                            var properties = PROPERTY_TEST_TARGETS[name];
                            if (properties && parentNode.type === "MemberExpression") {
                                var propertyName = (parentNode.computed ? getValueIfString : getIdentifierName)(parentNode.property);
                                if (properties.indexOf(propertyName) !== -1) {
                                    continue;
                                }
                            }

                            report(reference.identifier, name);
                        }
                    } catch (err) {
                        _didIteratorError6 = true;
                        _iteratorError6 = err;
                    } finally {
                        try {
                            if (!_iteratorNormalCompletion6 && _iterator6.return) {
                                _iterator6.return();
                            }
                        } finally {
                            if (_didIteratorError6) {
                                throw _iteratorError6;
                            }
                        }
                    }
                }

                // Check static methods.
            } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                    }
                } finally {
                    if (_didIteratorError3) {
                        throw _iteratorError3;
                    }
                }
            }

            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = getReferences(Object.keys(PROPERTY_TEST_TARGETS))[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var _reference = _step4.value;

                    var _node = _reference.identifier;
                    var _parentNode = _node.parent;
                    if (_parentNode.type !== "MemberExpression" || _parentNode.object !== _node) {
                        continue;
                    }

                    var objectName = _node.name;
                    var _properties = PROPERTY_TEST_TARGETS[objectName];
                    var _propertyName = (_parentNode.computed ? getValueIfString : getIdentifierName)(_parentNode.property);
                    if (_propertyName && _properties.indexOf(_propertyName) !== -1) {
                        report(_parentNode, objectName + "." + _propertyName);
                    }
                }

                // Check subclassing
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }

            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = getReferences(SUBCLASSING_TEST_TARGETS)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var _reference2 = _step5.value;

                    var _node2 = _reference2.identifier;
                    var _parentNode2 = _node2.parent;
                    if (CLASS_TYPE.test(_parentNode2.type) && _parentNode2.superClass === _node2) {
                        report(_node2, "extends" + _node2.name);
                    }
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }
        },


        //----------------------------------------------------------------------
        // Functions
        //----------------------------------------------------------------------

        "ArrowFunctionExpression": function ArrowFunctionExpression(node) {
            report(node, "arrowFunctions");
            if (node.async) {
                report(node, "asyncAwait");
            }
            if (hasTrailingCommaForFunction(node)) {
                report(node, "trailingCommasInFunctions");
            }
        },
        "AssignmentPattern": function AssignmentPattern(node) {
            if (FUNC_TYPE.test(node.parent.type)) {
                report(node, "defaultParameters");
            }
        },
        "FunctionDeclaration": function FunctionDeclaration(node) {
            var scope = context.getScope().upper;
            if (!TOPLEVEL_SCOPE_TYPE.test(scope.type)) {
                report(node, "blockScopedFunctions");
            }
            if (node.generator) {
                report(node, "generatorFunctions");
            }
            if (node.async) {
                report(node, "asyncAwait");
            }
            if (hasTrailingCommaForFunction(node)) {
                report(node, "trailingCommasInFunctions");
            }
            if (node.async && node.generator) {
                report(node, "asyncGenerators");
            }
        },
        "FunctionExpression": function FunctionExpression(node) {
            if (node.generator) {
                report(node, "generatorFunctions");
            }
            if (node.async) {
                report(node, "asyncAwait");
            }
            if (hasTrailingCommaForFunction(node)) {
                report(node, "trailingCommasInFunctions");
            }
            if (node.async && node.generator) {
                report(node, "asyncGenerators");
            }
        },
        "MetaProperty": function MetaProperty(node) {
            var meta = node.meta.name || node.meta;
            var property = node.property.name || node.property;
            if (meta === "new" && property === "target") {
                report(node, "new.target");
            }
        },


        //----------------------------------------------------------------------
        // Classes
        //----------------------------------------------------------------------

        "ClassDeclaration": function ClassDeclaration(node) {
            report(node, "classes");

            if (extendsNull(node)) {
                report(node, "extendsNull");
            }
        },
        "ClassExpression": function ClassExpression(node) {
            report(node, "classes");

            if (extendsNull(node)) {
                report(node, "extendsNull");
            }
        },


        //----------------------------------------------------------------------
        // Statements
        //----------------------------------------------------------------------

        "ForOfStatement": function ForOfStatement(node) {
            report(node, "forOf");
            if (node.await) {
                report(node, "forAwaitOf");
            }
        },
        "VariableDeclaration": function VariableDeclaration(node) {
            if (node.kind === "const") {
                report(node, "const");
            } else if (node.kind === "let") {
                report(node, "let");
            }
        },


        //----------------------------------------------------------------------
        // Expressions
        //----------------------------------------------------------------------

        "ArrayPattern": function ArrayPattern(node) {
            if (DESTRUCTURING_PARENT_TYPE.test(node.parent.type)) {
                report(node, "destructuring");
            }
        },
        "AssignmentExpression": function AssignmentExpression(node) {
            if (node.operator === "**=") {
                report(node, "exponentialOperators");
            }
        },
        "AwaitExpression": function AwaitExpression(node) {
            report(node, "asyncAwait");
        },
        "BinaryExpression": function BinaryExpression(node) {
            if (node.operator === "**") {
                report(node, "exponentialOperators");
            }
        },
        "CallExpression": function CallExpression(node) {
            if (hasTrailingCommaForCall(node)) {
                report(node, "trailingCommasInFunctions");
            }
        },
        "Identifier": function Identifier(node) {
            var raw = sourceCode.getText(node);
            if (hasUnicodeCodePointEscape(raw)) {
                report(node, "unicodeCodePointEscapes");
            }
        },
        "Literal": function Literal(node) {
            if (typeof node.value === "number") {
                if (BINARY_NUMBER.test(node.raw)) {
                    report(node, "binaryNumberLiterals");
                } else if (OCTAL_NUMBER.test(node.raw)) {
                    report(node, "octalNumberLiterals");
                }
            } else if (typeof node.value === "string") {
                if (hasUnicodeCodePointEscape(node.raw)) {
                    report(node, "unicodeCodePointEscapes");
                }
            } else if (node.regex) {
                validateRegExpLiteral(node);
            }
        },
        "NewExpression": function NewExpression(node) {
            if (node.callee.type === "Identifier" && node.callee.name === "RegExp") {
                validateRegExpString(node);
            }
            if (hasTrailingCommaForCall(node)) {
                report(node, "trailingCommasInFunctions");
            }
        },
        "ObjectPattern": function ObjectPattern(node) {
            if (DESTRUCTURING_PARENT_TYPE.test(node.parent.type)) {
                report(node, "destructuring");
            }
        },
        "Property": function Property(node) {
            if (node.parent.type === "ObjectExpression" && (node.computed || node.shorthand || node.method)) {
                if (node.shorthand && GET_OR_SET.test(node.key.name)) {
                    report(node, "objectPropertyShorthandOfGetSet");
                } else {
                    report(node, "objectLiteralExtensions");
                }
            }
        },
        "RestElement": function RestElement(node) {
            if (FUNC_TYPE.test(node.parent.type)) {
                report(node, "restParameters");
            } else if (node.parent.type === "ObjectPattern") {
                report(node, "restProperties");
            }
        },
        "SpreadElement": function SpreadElement(node) {
            if (node.parent.type === "ObjectExpression") {
                report(node, "spreadProperties");
            } else {
                report(node, "spreadOperators");
            }
        },
        "TemplateElement": function TemplateElement(node) {
            if (node.value.cooked == null) {
                report(node, "templateLiteralRevision");
            }
        },
        "TemplateLiteral": function TemplateLiteral(node) {
            report(node, "templateStrings");
        },


        //----------------------------------------------------------------------
        // Legacy
        //----------------------------------------------------------------------

        "ExperimentalRestProperty": function ExperimentalRestProperty(node) {
            report(node, "restProperties");
        },
        "ExperimentalSpreadProperty": function ExperimentalSpreadProperty(node) {
            report(node, "spreadProperties");
        },
        "RestProperty": function RestProperty(node) {
            report(node, "restProperties");
        },
        "SpreadProperty": function SpreadProperty(node) {
            report(node, "spreadProperties");
        },


        //----------------------------------------------------------------------
        // Modules
        //----------------------------------------------------------------------

        "ExportAllDeclaration": function ExportAllDeclaration(node) {
            report(node, "modules");
        },
        "ExportDefaultDeclaration": function ExportDefaultDeclaration(node) {
            report(node, "modules");
        },
        "ExportNamedDeclaration": function ExportNamedDeclaration(node) {
            report(node, "modules");
        },
        "ImportDeclaration": function ImportDeclaration(node) {
            report(node, "modules");
        }
    };
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    create: create,
    meta: {
        docs: {
            description: "disallow unsupported ECMAScript features on the specified version",
            category: "Possible Errors",
            recommended: true,
            url: getDocsUrl("no-unsupported-features.md")
        },
        fixable: false,
        schema: [{
            anyOf: [VERSION_SCHEMA.anyOf[0], VERSION_SCHEMA.anyOf[1], {
                type: "object",
                properties: {
                    version: VERSION_SCHEMA,
                    ignores: {
                        type: "array",
                        items: { enum: getIgnoresEnum() },
                        uniqueItems: true
                    }
                },
                additionalProperties: false
            }]
        }]
    }
};