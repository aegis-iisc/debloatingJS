/**
 * @fileoverview Rule to disallow deprecated API.
 * @author Toru Nagashima
 * @copyright 2016 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var deprecatedApis = require("../util/deprecated-apis");
var getDocsUrl = require("../util/get-docs-url");
var getValueIfString = require("../util/get-value-if-string");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

var SENTINEL_TYPE = /^(?:.+?Statement|.+?Declaration|(?:Array|ArrowFunction|Assignment|Call|Class|Function|Member|New|Object)Expression|AssignmentPattern|Program|VariableDeclarator)$/;
var MODULE_ITEMS = getDeprecatedItems(deprecatedApis.modules, [], []);
var GLOBAL_ITEMS = getDeprecatedItems(deprecatedApis.globals, [], []);

/**
 * Gets the array of deprecated items.
 *
 * It's the paths which are separated by dots.
 * E.g. `buffer.Buffer`, `events.EventEmitter.listenerCount`
 *
 * @param {object} definition - The definition of deprecated APIs.
 * @param {string[]} result - The array of the result.
 * @param {string[]} stack - The array to manage the stack of paths.
 * @returns {string[]} `result`.
 */
function getDeprecatedItems(definition, result, stack) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
        for (var _iterator = Object.keys(definition)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var key = _step.value;

            var item = definition[key];

            if (key === "$call") {
                result.push(stack.join(".") + "()");
            } else if (key === "$constructor") {
                result.push("new " + stack.join(".") + "()");
            } else {
                stack.push(key);

                if (item.$deprecated) {
                    result.push(stack.join("."));
                } else {
                    getDeprecatedItems(item, result, stack);
                }

                stack.pop();
            }
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
            }
        } finally {
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }

    return result;
}

/**
 * Converts from a version number to a version text to display.
 *
 * @param {number} value - A version number to convert.
 * @returns {string} Covnerted text.
 */
function toVersionText(value) {
    if (value <= 0.12) {
        return value.toFixed(2);
    }
    if (value < 1) {
        return value.toFixed(1);
    }
    return String(value);
}

/**
 * Makes a replacement message.
 *
 * @param {string|null} replacedBy - The text of substitute way.
 * @returns {string} Replacement message.
 */
function toReplaceMessage(replacedBy) {
    return replacedBy ? " Use " + replacedBy + " instead." : "";
}

/**
 * Gets the property name from a MemberExpression node or a Property node.
 *
 * @param {ASTNode} node - A node to get.
 * @returns {string|null} The property name of the node.
 */
function getPropertyName(node) {
    switch (node.type) {
        case "MemberExpression":
            if (node.computed) {
                return getValueIfString(node.property);
            }
            return node.property.name;

        case "Property":
            if (node.computed) {
                return getValueIfString(node.key);
            }
            if (node.key.type === "Literal") {
                return String(node.key.value);
            }
            return node.key.name;

        // no default
    }

    /* istanbul ignore next: unreachable */
    return null;
}

/**
 * Checks a given node is a ImportDeclaration node.
 *
 * @param {ASTNode} node - A node to check.
 * @returns {boolean} `true` if the node is a ImportDeclaration node.
 */
function isImportDeclaration(node) {
    return node.type === "ImportDeclaration";
}

/**
 * Finds the variable object of a given Identifier node.
 *
 * @param {ASTNode} node - An Identifier node to find.
 * @param {escope.Scope} initialScope - A scope to start searching.
 * @returns {escope.Variable} Found variable object.
 */
function findVariable(node, initialScope) {
    var location = node.range[0];
    var variable = null;

    // Dive into the scope that the node exists.
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
        for (var _iterator2 = initialScope.childScopes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var childScope = _step2.value;

            var range = childScope.block.range;

            if (range[0] <= location && location < range[1]) {
                variable = findVariable(node, childScope);
                if (variable != null) {
                    return variable;
                }
            }
        }

        // Find the variable of that name in this scope or ancestor scopes.
    } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
    } finally {
        try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
            }
        } finally {
            if (_didIteratorError2) {
                throw _iteratorError2;
            }
        }
    }

    var scope = initialScope;
    while (scope != null) {
        variable = scope.set.get(node.name);
        if (variable != null) {
            return variable;
        }

        scope = scope.upper;
    }

    return null;
}

/**
 * Gets the top member expression node.
 *
 * @param {ASTNode} identifier - The node to get.
 * @returns {ASTNode} The top member expression node.
 */
function getTopMemberExpression(identifier) {
    if (identifier.type !== "Identifier" && identifier.type !== "Literal") {
        return identifier;
    }

    var node = identifier;
    while (node.parent.type === "MemberExpression") {
        node = node.parent;
    }

    return node;
}

/**
 * The definition of this rule.
 *
 * @param {RuleContext} context - The rule context to check.
 * @returns {object} The definition of this rule.
 */
function create(context) {
    var options = context.options[0] || {};
    var ignoredModuleItems = options.ignoreModuleItems || [];
    var ignoredGlobalItems = options.ignoreGlobalItems || [];
    var globalScope = null;
    var varStack = [];

    /**
     * Reports a use of a deprecated API.
     *
     * @param {ASTNode} node - A node to report.
     * @param {string} name - The name of a deprecated API.
     * @param {{since: number, replacedBy: string}} info - Information of the API.
     * @returns {void}
     */
    function report(node, name, info) {
        context.report({
            node: node,
            loc: getTopMemberExpression(node).loc,
            message: "{{name}} was deprecated since v{{version}}.{{replace}}",
            data: {
                name: name,
                version: toVersionText(info.since),
                replace: toReplaceMessage(info.replacedBy)
            }
        });
    }

    /**
     * Reports a use of a deprecated module.
     *
     * @param {ASTNode} node - A node to report.
     * @param {string} name - The name of a deprecated module.
     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the module.
     * @returns {void}
     */
    function reportModule(node, name, info) {
        if (ignoredModuleItems.indexOf(name) === -1) {
            report(node, "'" + name + "' module", info);
        }
    }

    /**
     * Reports a use of a deprecated property.
     *
     * @param {ASTNode} node - A node to report.
     * @param {string[]} path - The path to a deprecated property.
     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.
     * @returns {void}
     */
    function reportCall(node, path, info) {
        var ignored = info.global ? ignoredGlobalItems : ignoredModuleItems;
        var name = path.join(".") + "()";

        if (ignored.indexOf(name) === -1) {
            report(node, "'" + name + "'", info);
        }
    }

    /**
     * Reports a use of a deprecated property.
     *
     * @param {ASTNode} node - A node to report.
     * @param {string[]} path - The path to a deprecated property.
     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.
     * @returns {void}
     */
    function reportConstructor(node, path, info) {
        var ignored = info.global ? ignoredGlobalItems : ignoredModuleItems;
        var name = "new " + path.join(".") + "()";

        if (ignored.indexOf(name) === -1) {
            report(node, "'" + name + "'", info);
        }
    }

    /**
     * Reports a use of a deprecated property.
     *
     * @param {ASTNode} node - A node to report.
     * @param {string[]} path - The path to a deprecated property.
     * @param {string} key - The name of the property.
     * @param {{since: number, replacedBy: string, global: boolean}} info - Information of the property.
     * @returns {void}
     */
    function reportProperty(node, path, key, info) {
        var ignored = info.global ? ignoredGlobalItems : ignoredModuleItems;

        path.push(key);
        var name = path.join(".");
        path.pop();

        if (ignored.indexOf(name) === -1) {
            report(node, "'" + name + "'", info);
        }
    }

    /**
     * Checks violations in destructuring assignments.
     *
     * @param {ASTNode} node - A pattern node to check.
     * @param {string[]} path - The path to a deprecated property.
     * @param {object} infoMap - A map of properties' information.
     * @returns {void}
     */
    function checkDestructuring(node, path, infoMap) {
        switch (node.type) {
            case "AssignmentPattern":
                checkDestructuring(node.left, path, infoMap);
                break;

            case "Identifier":
                {
                    var variable = findVariable(node, globalScope);
                    if (variable != null) {
                        checkVariable(variable, path, infoMap);
                    }
                    break;
                }
            case "ObjectPattern":
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = undefined;

                try {
                    for (var _iterator3 = node.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                        var property = _step3.value;

                        var key = getPropertyName(property);
                        if (key != null && hasOwnProperty.call(infoMap, key)) {
                            var keyInfo = infoMap[key];
                            if (keyInfo.$deprecated) {
                                reportProperty(property.key, path, key, keyInfo);
                            } else {
                                path.push(key);
                                checkDestructuring(property.value, path, keyInfo);
                                path.pop();
                            }
                        }
                    }
                } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                } finally {
                    try {
                        if (!_iteratorNormalCompletion3 && _iterator3.return) {
                            _iterator3.return();
                        }
                    } finally {
                        if (_didIteratorError3) {
                            throw _iteratorError3;
                        }
                    }
                }

                break;

            // no default
        }
    }

    /**
     * Checks violations in properties.
     *
     * @param {ASTNode} root - A node to check.
     * @param {string[]} path - The path to a deprecated property.
     * @param {object} infoMap - A map of properties' information.
     * @returns {void}
     */
    function checkProperties(root, path, infoMap) {
        //eslint-disable-line complexity
        var node = root;
        while (!SENTINEL_TYPE.test(node.parent.type)) {
            node = node.parent;
        }

        var parent = node.parent;
        switch (parent.type) {
            case "CallExpression":
                if (parent.callee === node && infoMap.$call != null) {
                    reportCall(parent, path, infoMap.$call);
                }
                break;

            case "NewExpression":
                if (parent.callee === node && infoMap.$constructor != null) {
                    reportConstructor(parent, path, infoMap.$constructor);
                }
                break;

            case "MemberExpression":
                if (parent.object === node) {
                    var key = getPropertyName(parent);
                    if (key != null && hasOwnProperty.call(infoMap, key)) {
                        var keyInfo = infoMap[key];
                        if (keyInfo.$deprecated) {
                            reportProperty(parent.property, path, key, keyInfo);
                        } else {
                            path.push(key);
                            checkProperties(parent, path, keyInfo);
                            path.pop();
                        }
                    }
                }
                break;

            case "AssignmentExpression":
                if (parent.right === node) {
                    checkDestructuring(parent.left, path, infoMap);
                    checkProperties(parent, path, infoMap);
                }
                break;

            case "AssignmentPattern":
                if (parent.right === node) {
                    checkDestructuring(parent.left, path, infoMap);
                }
                break;

            case "VariableDeclarator":
                if (parent.init === node) {
                    checkDestructuring(parent.id, path, infoMap);
                }
                break;

            // no default
        }
    }

    /**
     * Checks violations in the references of a given variable.
     *
     * @param {escope.Variable} variable - A variable to check.
     * @param {string[]} path - The path to a deprecated property.
     * @param {object} infoMap - A map of properties' information.
     * @returns {void}
     */
    function checkVariable(variable, path, infoMap) {
        if (varStack.indexOf(variable) !== -1) {
            return;
        }
        varStack.push(variable);

        if (infoMap.$deprecated) {
            var key = path.pop();
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
                for (var _iterator4 = variable.references.filter(function (r) {
                    return r.isRead();
                })[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    var reference = _step4.value;

                    reportProperty(reference.identifier, path, key, infoMap);
                }
            } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion4 && _iterator4.return) {
                        _iterator4.return();
                    }
                } finally {
                    if (_didIteratorError4) {
                        throw _iteratorError4;
                    }
                }
            }
        } else {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
                for (var _iterator5 = variable.references.filter(function (r) {
                    return r.isRead();
                })[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                    var _reference = _step5.value;

                    checkProperties(_reference.identifier, path, infoMap);
                }
            } catch (err) {
                _didIteratorError5 = true;
                _iteratorError5 = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                    }
                } finally {
                    if (_didIteratorError5) {
                        throw _iteratorError5;
                    }
                }
            }
        }

        varStack.pop();
    }

    /**
     * Checks violations in a ModuleSpecifier node.
     *
     * @param {ASTNode} node - A ModuleSpecifier node to check.
     * @param {string[]} path - The path to a deprecated property.
     * @param {object} infoMap - A map of properties' information.
     * @returns {void}
     */
    function checkImportSpecifier(node, path, infoMap) {
        switch (node.type) {
            case "ImportSpecifier":
                {
                    var key = node.imported.name;
                    if (hasOwnProperty.call(infoMap, key)) {
                        var keyInfo = infoMap[key];
                        if (keyInfo.$deprecated) {
                            reportProperty(node.imported, path, key, keyInfo);
                        } else {
                            path.push(key);
                            checkVariable(findVariable(node.local, globalScope), path, keyInfo);
                            path.pop();
                        }
                    }
                    break;
                }
            case "ImportDefaultSpecifier":
                checkVariable(findVariable(node.local, globalScope), path, infoMap);
                break;

            case "ImportNamespaceSpecifier":
                checkVariable(findVariable(node.local, globalScope), path, Object.assign({}, infoMap, { default: infoMap }));
                break;

            // no default
        }
    }

    /**
     * Checks violations for CommonJS modules.
     * @returns {void}
     */
    function checkCommonJsModules() {
        var infoMap = deprecatedApis.modules;
        var variable = globalScope.set.get("require");

        if (variable == null || variable.defs.length !== 0) {
            return;
        }

        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
            for (var _iterator6 = variable.references.filter(function (r) {
                return r.isRead();
            })[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var reference = _step6.value;

                var id = reference.identifier;
                var node = id.parent;

                if (node.type === "CallExpression" && node.callee === id) {
                    var key = getValueIfString(node.arguments[0]);
                    if (key != null && hasOwnProperty.call(infoMap, key)) {
                        var moduleInfo = infoMap[key];
                        if (moduleInfo.$deprecated) {
                            reportModule(node, key, moduleInfo);
                        } else {
                            checkProperties(node, [key], moduleInfo);
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                    _iterator6.return();
                }
            } finally {
                if (_didIteratorError6) {
                    throw _iteratorError6;
                }
            }
        }
    }

    /**
     * Checks violations for ES2015 modules.
     * @param {ASTNode} programNode - A program node to check.
     * @returns {void}
     */
    function checkES2015Modules(programNode) {
        var infoMap = deprecatedApis.modules;

        var _iteratorNormalCompletion7 = true;
        var _didIteratorError7 = false;
        var _iteratorError7 = undefined;

        try {
            for (var _iterator7 = programNode.body.filter(isImportDeclaration)[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var node = _step7.value;

                var key = node.source.value;
                if (hasOwnProperty.call(infoMap, key)) {
                    var moduleInfo = infoMap[key];
                    if (moduleInfo.$deprecated) {
                        reportModule(node, key, moduleInfo);
                    } else {
                        var _iteratorNormalCompletion8 = true;
                        var _didIteratorError8 = false;
                        var _iteratorError8 = undefined;

                        try {
                            for (var _iterator8 = node.specifiers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                                var specifier = _step8.value;

                                checkImportSpecifier(specifier, [key], moduleInfo);
                            }
                        } catch (err) {
                            _didIteratorError8 = true;
                            _iteratorError8 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion8 && _iterator8.return) {
                                    _iterator8.return();
                                }
                            } finally {
                                if (_didIteratorError8) {
                                    throw _iteratorError8;
                                }
                            }
                        }
                    }
                }
            }
        } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                }
            } finally {
                if (_didIteratorError7) {
                    throw _iteratorError7;
                }
            }
        }
    }

    /**
     * Checks violations for global variables.
     * @returns {void}
     */
    function checkGlobals() {
        var infoMap = deprecatedApis.globals;

        var _iteratorNormalCompletion9 = true;
        var _didIteratorError9 = false;
        var _iteratorError9 = undefined;

        try {
            for (var _iterator9 = Object.keys(infoMap)[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var key = _step9.value;

                var keyInfo = infoMap[key];
                var variable = globalScope.set.get(key);

                if (variable != null && variable.defs.length === 0) {
                    checkVariable(variable, [key], keyInfo);
                }
            }
        } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
        } finally {
            try {
                if (!_iteratorNormalCompletion9 && _iterator9.return) {
                    _iterator9.return();
                }
            } finally {
                if (_didIteratorError9) {
                    throw _iteratorError9;
                }
            }
        }
    }

    return {
        "Program:exit": function ProgramExit(node) {
            globalScope = context.getScope();

            checkCommonJsModules();
            checkES2015Modules(node);
            checkGlobals();
        }
    };
}

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    create: create,
    meta: {
        docs: {
            description: "disallow deprecated APIs",
            category: "Best Practices",
            recommended: true,
            url: getDocsUrl("no-deprecated-api.md")
        },
        fixable: false,
        schema: [{
            type: "object",
            properties: {
                ignoreModuleItems: {
                    type: "array",
                    items: { enum: MODULE_ITEMS },
                    additionalItems: false,
                    uniqueItems: true
                },
                ignoreGlobalItems: {
                    type: "array",
                    items: { enum: GLOBAL_ITEMS },
                    additionalItems: false,
                    uniqueItems: true
                },

                // Deprecated since v4.2.0
                ignoreIndirectDependencies: { type: "boolean" }
            },
            additionalProperties: false
        }]
    }
};