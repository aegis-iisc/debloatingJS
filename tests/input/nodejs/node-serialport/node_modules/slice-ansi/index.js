'use strict';

var isFullwidthCodePoint = require('is-fullwidth-code-point');

var ESCAPES = ['\x1B', '\x9B'];

var END_CODE = 39;
var ASTRAL_REGEX = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;

var ESCAPE_CODES = new Map([[0, 0], [1, 22], [2, 22], [3, 23], [4, 24], [7, 27], [8, 28], [9, 29], [30, 39], [31, 39], [32, 39], [33, 39], [34, 39], [35, 39], [36, 39], [37, 39], [90, 39], [40, 49], [41, 49], [42, 49], [43, 49], [44, 49], [45, 49], [46, 49], [47, 49]]);

var wrapAnsi = function wrapAnsi(code) {
	return ESCAPES[0] + '[' + code + 'm';
};

module.exports = function (str, begin, end) {
	var arr = Array.from(str.normalize());

	end = typeof end === 'number' ? end : arr.length;

	var insideEscape = false;
	var escapeCode = void 0;
	var visible = 0;
	var output = '';

	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = arr.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var item = _step.value;

			var i = item[0];
			var x = item[1];

			var leftEscape = false;

			if (ESCAPES.indexOf(x) !== -1) {
				insideEscape = true;
				var code = /\d[^m]*/.exec(str.slice(i, i + 4));
				escapeCode = code === END_CODE ? null : code;
			} else if (insideEscape && x === 'm') {
				insideEscape = false;
				leftEscape = true;
			}

			if (!insideEscape && !leftEscape) {
				++visible;
			}

			if (!ASTRAL_REGEX.test(x) && isFullwidthCodePoint(x.codePointAt())) {
				++visible;
			}

			if (visible > begin && visible <= end) {
				output += x;
			} else if (visible === begin && !insideEscape && escapeCode !== undefined && escapeCode !== END_CODE) {
				output += wrapAnsi(escapeCode);
			} else if (visible >= end) {
				if (escapeCode !== undefined) {
					output += wrapAnsi(ESCAPE_CODES.get(parseInt(escapeCode, 10)) || END_CODE);
				}
				break;
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	return output;
};