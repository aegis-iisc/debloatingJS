/**
 * @fileoverview Implements the Node.js require.resolve algorithm
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Module = require("module");

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

var DEFAULT_OPTIONS = {

  /*
   * module.paths is an array of paths to search for resolving things relative
   * to this file. Module.globalPaths contains all of the special Node.js
   * directories that can also be searched for modules.
   *
   * Need to check for existence of module.paths because Jest seems not to
   * include it. See https://github.com/eslint/eslint/issues/5791.
   */
  lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()
};

/**
 * Resolves modules based on a set of options.
 */

var ModuleResolver = function () {

  /**
   * Resolves modules based on a set of options.
   * @param {Object} options The options for resolving modules.
   * @param {string[]} options.lookupPaths An array of paths to include in the
   *      lookup with the highest priority paths coming first.
   */
  function ModuleResolver(options) {
    _classCallCheck(this, ModuleResolver);

    this.options = Object.assign({}, DEFAULT_OPTIONS, options || {});
  }

  /**
   * Resolves the file location of a given module relative to the configured
   * lookup paths.
   * @param {string} name The module name to resolve.
   * @param {string} extraLookupPath An extra path to look into for the module.
   *      This path is used with the highest priority.
   * @returns {string} The resolved file path for the module.
   * @throws {Error} If the module cannot be resolved.
   */


  _createClass(ModuleResolver, [{
    key: "resolve",
    value: function resolve(name, extraLookupPath) {

      /*
       * First, clone the lookup paths so we're not messing things up for
       * subsequent calls to this function. Then, move the extraLookupPath to the
       * top of the lookup paths list so it will be searched first.
       */
      var lookupPaths = this.options.lookupPaths.concat();

      lookupPaths.unshift(extraLookupPath);

      /**
       * Module._findPath is an internal method to Node.js, then one they use to
       * lookup file paths when require() is called. So, we are hooking into the
       * exact same logic that Node.js uses.
       */
      var result = Module._findPath(name, lookupPaths); // eslint-disable-line no-underscore-dangle

      if (!result) {
        throw new Error("Cannot find module '" + name + "'");
      }

      return result;
    }
  }]);

  return ModuleResolver;
}();

//------------------------------------------------------------------------------
// Public API
//------------------------------------------------------------------------------

module.exports = ModuleResolver;