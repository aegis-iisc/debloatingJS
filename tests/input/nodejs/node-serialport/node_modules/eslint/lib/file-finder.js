/**
 * @fileoverview Util class to find config files.
 * @author Aliaksei Shytkin
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require("fs"),
    path = require("path");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Get the entries for a directory. Including a try-catch may be detrimental to
 * function performance, so move it out here a separate function.
 * @param {string} directory The directory to search in.
 * @returns {string[]} The entries in the directory or an empty array on error.
 * @private
 */
function getDirectoryEntries(directory) {
    try {

        return fs.readdirSync(directory);
    } catch (ex) {
        return [];
    }
}

/**
 * Create a hash of filenames from a directory listing
 * @param {string[]} entries Array of directory entries.
 * @param {string} directory Path to a current directory.
 * @param {string[]} supportedConfigs List of support filenames.
 * @returns {Object} Hashmap of filenames
 */
function normalizeDirectoryEntries(entries, directory, supportedConfigs) {
    var fileHash = {};

    entries.forEach(function (entry) {
        if (supportedConfigs.indexOf(entry) >= 0) {
            var resolvedEntry = path.resolve(directory, entry);

            if (fs.statSync(resolvedEntry).isFile()) {
                fileHash[entry] = resolvedEntry;
            }
        }
    });
    return fileHash;
}

//------------------------------------------------------------------------------
// API
//------------------------------------------------------------------------------

/**
 * FileFinder class
 */

var FileFinder = function () {

    /**
     * @param {string[]} files The basename(s) of the file(s) to find.
     * @param {stirng} cwd Current working directory
     */
    function FileFinder(files, cwd) {
        _classCallCheck(this, FileFinder);

        this.fileNames = Array.isArray(files) ? files : [files];
        this.cwd = cwd || process.cwd();
        this.cache = {};
    }

    /**
     * Find all instances of files with the specified file names, in directory and
     * parent directories. Cache the results.
     * Does not check if a matching directory entry is a file.
     * Searches for all the file names in this.fileNames.
     * Is currently used by lib/config.js to find .eslintrc and package.json files.
     * @param  {string} relativeDirectory The directory to start the search from.
     * @returns {GeneratorFunction} to iterate the file paths found
     */


    _createClass(FileFinder, [{
        key: "findAllInDirectoryAndParents",
        value: /*#__PURE__*/regeneratorRuntime.mark(function findAllInDirectoryAndParents(relativeDirectory) {
            var cache, initialDirectory, dirs, fileNames, searched, directory, filesMap, k, filePath, j, child, i;
            return regeneratorRuntime.wrap(function findAllInDirectoryAndParents$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            cache = this.cache;
                            initialDirectory = relativeDirectory ? path.resolve(this.cwd, relativeDirectory) : this.cwd;

                            if (!cache.hasOwnProperty(initialDirectory)) {
                                _context.next = 5;
                                break;
                            }

                            return _context.delegateYield(cache[initialDirectory], "t0", 4);

                        case 4:
                            return _context.abrupt("return");

                        case 5:
                            dirs = [];
                            fileNames = this.fileNames;
                            searched = 0;
                            directory = initialDirectory;

                        case 9:
                            dirs[searched++] = directory;
                            cache[directory] = [];

                            filesMap = normalizeDirectoryEntries(getDirectoryEntries(directory), directory, fileNames);

                            if (!Object.keys(filesMap).length) {
                                _context.next = 24;
                                break;
                            }

                            k = 0;

                        case 14:
                            if (!(k < fileNames.length)) {
                                _context.next = 24;
                                break;
                            }

                            if (!filesMap[fileNames[k]]) {
                                _context.next = 21;
                                break;
                            }

                            filePath = filesMap[fileNames[k]];

                            // Add the file path to the cache of each directory searched.

                            for (j = 0; j < searched; j++) {
                                cache[dirs[j]].push(filePath);
                            }
                            _context.next = 20;
                            return filePath;

                        case 20:
                            return _context.abrupt("break", 24);

                        case 21:
                            k++;
                            _context.next = 14;
                            break;

                        case 24:
                            child = directory;

                            // Assign parent directory to directory.

                            directory = path.dirname(directory);

                            if (!(directory === child)) {
                                _context.next = 28;
                                break;
                            }

                            return _context.abrupt("return");

                        case 28:
                            if (!cache.hasOwnProperty(directory)) {
                                _context.next = 9;
                                break;
                            }

                        case 29:

                            // Add what has been cached previously to the cache of each directory searched.
                            for (i = 0; i < searched; i++) {
                                [].push.apply(cache[dirs[i]], cache[directory]);
                            }

                            return _context.delegateYield(cache[dirs[0]], "t1", 31);

                        case 31:
                        case "end":
                            return _context.stop();
                    }
                }
            }, findAllInDirectoryAndParents, this);
        })
    }]);

    return FileFinder;
}();

module.exports = FileFinder;