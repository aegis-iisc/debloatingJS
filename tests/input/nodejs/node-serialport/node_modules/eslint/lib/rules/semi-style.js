/**
 * @fileoverview Rule to enforce location of semicolons.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var astUtils = require("../ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

var SELECTOR = ":matches(" + ["BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExpressionStatement", "ImportDeclaration", "ReturnStatement", "ThrowStatement", "VariableDeclaration"].join(",") + ")";

/**
 * Get the child node list of a given node.
 * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.
 * This is used to check whether a node is the first/last child.
 * @param {Node} node A node to get child node list.
 * @returns {Node[]|null} The child node list.
 */
function getChildren(node) {
    var t = node.type;

    if (t === "BlockStatement" || t === "Program") {
        return node.body;
    }
    if (t === "SwitchCase") {
        return node.consequent;
    }
    return null;
}

/**
 * Check whether a given node is the last statement in the parent block.
 * @param {Node} node A node to check.
 * @returns {boolean} `true` if the node is the last statement in the parent block.
 */
function isLastChild(node) {
    var t = node.parent.type;

    if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
        // before `else` keyword.
        return true;
    }
    if (t === "DoWhileStatement") {
        // before `while` keyword.
        return true;
    }
    var nodeList = getChildren(node.parent);

    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `}` or etc.
}

module.exports = {
    meta: {
        docs: {
            description: "enforce location of semicolons",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/semi-style"
        },
        schema: [{ enum: ["last", "first"] }],
        fixable: "whitespace"
    },

    create: function create(context) {
        var _ref;

        var sourceCode = context.getSourceCode();
        var option = context.options[0] || "last";

        /**
         * Check the given semicolon token.
         * @param {Token} semiToken The semicolon token to check.
         * @param {"first"|"last"} expected The expected location to check.
         * @returns {void}
         */
        function check(semiToken, expected) {
            var prevToken = sourceCode.getTokenBefore(semiToken);
            var nextToken = sourceCode.getTokenAfter(semiToken);
            var prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
            var nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);

            if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
                context.report({
                    loc: semiToken.loc,
                    message: "Expected this semicolon to be at {{pos}}.",
                    data: {
                        pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
                    },
                    fix: function fix(fixer) {
                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
                            return null;
                        }

                        var start = prevToken ? prevToken.range[1] : semiToken.range[0];
                        var end = nextToken ? nextToken.range[0] : semiToken.range[1];
                        var text = expected === "last" ? ";\n" : "\n;";

                        return fixer.replaceTextRange([start, end], text);
                    }
                });
            }
        }

        return _ref = {}, _defineProperty(_ref, SELECTOR, function (node) {
            if (option === "first" && isLastChild(node)) {
                return;
            }

            var lastToken = sourceCode.getLastToken(node);

            if (astUtils.isSemicolonToken(lastToken)) {
                check(lastToken, option);
            }
        }), _defineProperty(_ref, "ForStatement", function ForStatement(node) {
            var firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
            var secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);

            if (firstSemi) {
                check(firstSemi, "last");
            }
            if (secondSemi) {
                check(secondSemi, "last");
            }
        }), _ref;
    }
};